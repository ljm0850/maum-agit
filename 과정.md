# 도커
1. 백엔드 & 프론트엔드 3번까지 진행
2. docker-compose.yml 파일을 root에 생성한 후 작성
3. docker container 빌드 및 실행 `docker compose up -d --build`
    - 기존에 3306포트를 mySQL에서 사용하고 있어서 에러 발생 -> mySQL 작동 중지 후 다시 실행
    - 컨테이너 목록 확인 `docker ps`

# 백엔드
1. nestjs 프로젝트 설치
- `nest new . --strict --skip-install`
2. 패키지 설치
- `npm install `
3. 도커 파일 생성
- /backend/Dockerfile.dev

4. MySQL 연결
- TypeORM 설치
    - `npm install @nestjs/typeorm typeorm mysql2`
    - `npm install --save-dev @types/node`
    - sql injection을 해결하는 코드가 포함됨
- .env 파일 쉽게 다루기 위한 패키지 (`npm install @nestjs/config`)
- db 모듈 설정(src/app.module.ts 작성)
- 다시 도커를 띄운 후 확인

5. 모듈 설정 및 하위 모듈 생성
- `backend/src/app.module.ts`에 ConfigModule(.env 사용), TypeOrmModule(db orm 사용) 작성
- `nest g module 하위모듈 이름` 으로 하위 모듈 생성
- AppModule(src/app.module.ts 파일)에 하위 모듈 등록
- 엔티티 파일 정의(각 하위 모듈에서 하위.entity.ts 작성)
- 정의한 엔티티 파일을 하위.module.ts 파일에 등록
- post 하위 엔티티(Image ...) 작성 및 post.module.ts에 등록(import에 추가)

6. auth API 구현
- **Passport.js** 설치 : Auth를 처리하기 위한 미들웨어
    - `npm install @nestjs/passport passport passport-google-oauth20 @types/passport-google-oauth20`
        - `@nestjs/passport`: NestJS와 Passport를 통합하는 모듈
        - `passport`: Passport.js의 핵심 라이브러리.
        - `passport-google-oauth20`: Google OAuth 2.0 인증을 위한 Passport
        - `@types/passport-google-oauth20`: 지금까지의 패키지에 대한 TypeScript 타입 정의
    - `npm install @nestjs/jwt passport-jwt @types/passport-jwt`
        - `@nestjs/jwt`: NestJS에서 JWT(JSON Web Tokens)를 사용하기 위한 모듈.
        - `passport-jwt`: JWT 기반 인증을 위한 Passport
        - `@types/passport-jwt`위 두개의 패키지에 대한 type 정의
    - `npm install --save-dev @types/passport @types/express`
        - `--save-dev` : 개발용도로 사용, npm install 패키지 명에는 기본적으로 `--save-prod`가 생략되있는 것
        - `@types/express`: express 프레임워크의 Request와 Response 객체에 대한 타입 정의, AuthController에서 req, res 타입 사용 시 필요
- auth 폴더 및 파일 생성 후 작성
    - `nest g module 모듈이름(auth)` 모듈 생성 후 app.module.ts에 등록
    - `nest g service 서비스이름(auth)`
    - `nest g controller 컨트롤러이름(auth)`
    - ... 많은 일이 있었음
        - jwt.strategy.ts,
        - google.strategy.ts
7. username 변경 및 회원탈퇴 api 구현
- user.controller & user.service 생성(`nest g service user` & `nest g controller user`)
    - user.module.ts에 import와 controller & provider는 등록되니 exports에 service 추가
- dto?
    - 클라이언트로 부터 받을 데이터를 정의
    - `npm install class-validator class-transformer`를 활용

- InjectRepository 메서드 정리

    - ```typescript
        export class UserService {
          constructor(
            @InjectRepository(User)
            private userRepository: Repository<User>,
          ) {}
        } // 라고 설정
        // create: 생성
        const newuser = this.userRepository.create({...필요데이터});
        // save: db에 (생성된|업데이트된) 엔티티를 저장
        const savedUser = await this.userRepository.save(newUser);
        // findOne: 조건을 만족하는 단일 레코드 조회, 없으면 null
        const userById = await this.userRepository.findOne({ where: { id: 'ljm' } });
        // findOneBy: where 생략
        const userByEmail = await this.userRepository.findOneBy({ email: 'ljm의 email' });
        // find : 모든 레코드 조회, 배열로 반환
        const allUsers = await this.userRepository.find();
        const googleUsers = await this.userRepository.find({ where: { providerName: 'google' } });
        // delete : 삭제, 삭제된 행 개수 반환
        const deleteResult = await this.userRepository.delete({ email: 'user@example.com' });
        // update : 부분적 업데이트
        await this.userRepository.update({ id: 'ljm' }, { username: 'updated_u	ser_name' });
        ```
8. postAPI 작성
    - 글 생성 API
    - 글 목록 API
    - 글 조회 API

# 프론트엔드
1. nextjs 프로젝트 생성
- `npx create-next-app@latest . --ts --tailwind --eslint --app --no-src-dir --import-alias "@/*" --no-install`
- Turbopack 사용
2. 패키지 설치
- `npm install `
3. 도커 파일 생성
- /frontend/Dockerfile.dev

4. 폴더 구조 정리
- `/app` : 클라이언트에서 사용될 파일
- `/components` : 재사용 할 컴포넌트, app의 page.tsx가 컴포넌트를 불러올 예정
- `/lib` : 백엔드 api 관련 폴더
- `/public` : 사진 등 정적 파일
- `/stores` : 클라이언트 상태 관리용(Zustand)
- `types` : 타입 정의

5. 상태관리 라이브러리 설치 및 테스트
- `npm install zustand @tanstack/react-query @tanstack/react-query-devtools`
- react-query
    - **QueryClientProvider**를 통해 연결됨
    - `./src/providers/query-providers.tsx`에 QueryClientProvider 작성 -> root layout에서 감싸서 사용
- zustand
    - `/src/stores`

6. api Test
- axios 설치 (`npm install axios`)
- src/lib/api.ts 작성

7. 웹 페이지 방식
- 기본 주소 = 로그인 화면
    - 로그인 되어 있으면(jwt 토큰으로 확인 가능시) 게시물 리스트로 리다이렉트
- 구글 로그인 => auth/callback 주소 => accessToken 파싱 후 확인
    - 올바른 accessToken은 localStorage 저장 후 게시물 리스트로 리다이렉트
- 로그인 없이 posts, user 등에 접근시
    - 잘못된 접근입니다 => 로그인 화면 리다이렉트
    - layout에 해당 코드 삽입? => 클라이언트에서 처리 => 플리커현상이 발생할 수 있으므로 조절
    - 미들웨어에 해당 코드 삽입? => 서버에서 처리 => 플리커 현상은 없으나, localStorage 사용 불가 => 쿠키 사용해야함

8. 내 글 목록 불러오기 api가 너무 많은 데이터를 가져옴
- 백엔드에서 api 변경
- 이렇게 백엔드로 돌아가서 작업할 생각을 하니 backend,frontend 브런치 나눠서 하는게 좋았겠다는 생각이 든다.

9. 게시글 보는 페이지 모달로 변경
- 게시글 디테일 페이지를 두는 것이 프로젝트의 방향과 맞지 않다고 판단
    - 안좋은 기억과 감정을 남겨두고 추후 보고 별거 아니였네 라는 방향
    - 게시글 디테일 페이지는 너무 진중한? 무거운 느낌
- `posts/[id]` 접근 방식은 잘 모르는 사용자 입장에선 다른 사람의 글을 읽을 수 있는거 아니야? 라는 생각이 들 수 있음
- 기존의 `app/posts/[id]/page.tsx` 삭제

10. React-Query 관련 코드 리팩토링
- 각각의 컴포넌트에서 함수를 만들어서 사용하는 방식 관리가 힘들어서 관리를 위해 변경

11. css에 bootstrap 사용 결정
- 디자인과 css에 쏟을 시간에 기능 추가, 다른 프로젝트를 하는 것이 더 낫다고 판단

# 배포
- 프로젝트 처음에는 AWS EC2 서버에 도커와 nginx를 이용해서 백엔드, 프론트엔드를 각각 띄우려고 생각
- 현재는 EC2 서버에는 도커를 이용해서 백엔드를, 프론트엔드는 S3 서버를 사용하기로 결정
- 이로인해 Dockerfile을 비롯한 코드 변경이 필요
## 첫 시도
1. 초기 문제: 502 Bad Gateway 에러
- 원인: Nginx는 정상적으로 실행되지만, 백엔드 서버가 제대로 시작되지 않았기 때문입니다.
- 로그 에러: node: not found, Cannot find module '@nestjs/core' 같은 메시지로, 컨테이너 내부에 Node.js 런타임이나 의존성 패키지가 없음을 확인했습니다.

2. 해결 시도: Docker Compose로 배포 방식 변경
- 전략: Nginx와 백엔드를 각각 독립적인 컨테이너로 분리하여 docker-compose로 관리하기로 했습니다.

- 진행 과정
    - backend/Dockerfile과 nginx/Dockerfile을 각각 분리했습니다.
    - docker-compose.yml 파일을 작성하여 두 서비스를 정의했습니다.
    - EC2 인스턴스에 docker-compose.yml을 업로드했습니다.

3. 새로운 문제와 해결 과정
- 네트워크 및 scp 전송 문제
    - scp로 백엔드 폴더를 전송하는 과정에서 용량이 큰 node_modules 폴더 때문에 전송 시간이 오래 걸리거나 연결이 끊기는 문제가 발생
    - 해결책: rsync 명령어를 사용하여 변경된 파일만 전송하고, node_modules 같은 불필요한 폴더를 제외하는 방식으로 채택

- 컨테이너 빌드 오류
    - docker-compose up --build 실행 시 Cannot find module '@nestjs/core' 에러가 계속 발생했습니다.

4. 최종 결론 및 다음 단계
- 오늘의 모든 시도에도 불구하고 Cannot find module 에러를 최종적으로 해결하지는 못했습니다.
- 더 안정적이고 효율적인 방법으로 배포 과정을 다시 시작하기로 결정했습니다.
- ECR과 자동 배포(CI/CD)를 기준으로 처음부터 다시 시작하여, 파일 전송과 빌드 과정에서 발생하는 비효율을 제거하고 안정적인 배포 파이프라인 구축을 목표

## 두번째 시도
전체 배포 워크플로우
배포는 크게 세 단계로 이루어집니다. 코드를 수정한 뒤 로컬 환경에서 **ECR로 이미지를 푸시(Push)**하고, EC2 서버에서 ECR에 있는 이미지를 **풀(Pull)**하여 컨테이너를 실행하는 방식입니다.

1. 로컬 환경에서 코드 수정 및 이미지 빌드

이 단계는 당신의 로컬 PC에서 서비스의 코드를 변경하고, 이 변경사항을 **Dockerfile**을 이용해 Docker 이미지로 만드는 과정입니다.

코드 변경: 프론트엔드 또는 백엔드의 코드를 수정합니다.

이미지 빌드 및 ECR로 푸시: 수정된 코드가 포함된 새로운 이미지를 빌드하고 ECR에 업로드합니다.

프론트엔드 이미지 푸시 시:
```
Bash

docker buildx build --platform linux/amd64 -t 420606830898.dkr.ecr.ap-northeast-2.amazonaws.com/maum-agit-frontend:v1.0.1 . --push
```
백엔드 이미지 푸시 시:
```
Bash

docker buildx build --platform linux/amd64 -t 420606830898.dkr.ecr.ap-northeast-2.amazonaws.com/maum-agit-backend:v1.0.1 . --push
```
2. EC2 서버에서 최신 이미지로 배포
EC2 서버는 ECR 저장소에서 최신 이미지를 가져와 기존 컨테이너를 교체하는 역할을 합니다. 모든 작업은 docker-compose.yml 파일을 기반으로 이루어집니다.

기존 컨테이너 중지: 현재 실행 중인 모든 컨테이너를 정상적으로 중지하고 네트워크를 정리합니다.
```
Bash

docker-compose down
```
최신 이미지 풀(Pull): ECR에 업로드된 최신 이미지를 서버로 다운로드합니다.
```
Bash

docker-compose pull
```
전체 서비스 재실행: 최신 이미지를 사용하여 docker-compose.yml 파일에 정의된 모든 서비스(nginx, frontend, backend)를 실행합니다.
```
Bash

docker-compose up -d
```
3. 서비스 상태 확인 및 관리
배포 후, 모든 컨테이너가 정상적으로 동작하는지 확인하고 문제가 발생하면 로그를 통해 원인을 파악합니다.

컨테이너 상태 확인:
```
Bash

docker-compose ps
```
로그 확인:
```
Bash

docker-compose logs <서비스명>
```
예시: docker-compose logs backend

### 문제 발생
문제:
로컬 환경 재설치 및 빌드 과정에서 npm 의존성 충돌 오류가 발생했습니다. 특히 reflect-metadata 버전 관련 충돌(ERESOLVE)과, 이로 인한 @nestjs/common, @nestjs/typeorm 등 주요 모듈을 찾을 수 없다는 오류(Cannot find module)가 지속적으로 발생했습니다.

원인:
package.json 파일 내 다양한 라이브러리 버전 간의 호환성 문제가 원인으로 파악되었습니다. 특히 NestJS 생태계의 여러 패키지가 서로 다른 peer dependency를 요구했기 때문입니다.

해결 과정:

package.json 구문 오류 수정: 첫 번째로 발견된 package.json 파일의 구문 오류(EJSONPARSE)를 수정하여 기본적인 문제를 해결했습니다.

--legacy-peer-deps 옵션 사용: npm install --legacy-peer-deps 명령어를 사용해 버전 충돌 경고를 무시하고 모든 패키지를 강제로 설치했습니다. 이로써 Cannot find module 오류를 해결하고 빌드를 성공시킬 수 있었습니다.

Docker 네트워크 문제 해결: 빌드 성공 후, 백엔드 컨테이너가 데이터베이스 컨테이너(database)를 찾지 못하는 getaddrinfo ENOTFOUND 오류가 발생했습니다. 이는 Docker 컨테이너 간의 네트워크 통신 문제였습니다.

docker-compose.yml 수정: docker-compose.yml 파일에 공유 네트워크(my_network)를 정의하고 백엔드와 데이터베이스 컨테이너를 이 네트워크에 연결하여 통신 문제를 최종적으로 해결했습니다.

결론:
npm 의존성 충돌과 Docker 네트워크 설정이라는 두 가지 주요 문제를 해결하여 로컬 환경 재설치 및 빌드, 그리고 Docker 컨테이너 간의 연결 문제를 모두 해결했습니다.

### 배포 과정에서 발생한 일들
데이터베이스 접속 오류 (502): 백엔드 컨테이너가 데이터베이스에 연결하지 못해 발생하는 오류였습니다. docker-compose.yml에 **MYSQL_USER**와 **MYSQL_PASSWORD**를 명시적으로 설정하여 데이터베이스가 올바르게 초기화되도록 해결했습니다.

컨테이너 즉시 종료 오류 (502): 데이터베이스 문제는 해결되었지만, 백엔드 컨테이너가 시작 직후 종료되는 문제가 발생했습니다. command: npm run start:prod 옵션을 docker-compose.yml에 추가하여 백엔드 프로세스가 계속 실행되도록 수정했습니다.

라우팅 오류 (404): 백엔드가 실행되었지만, Nginx가 /api/ 접두사를 제거하지 않고 요청을 그대로 보내 404 Not Found가 발생했습니다. Nginx 설정 파일(default.conf)의 rewrite 규칙 주석을 해제하여 경로를 올바르게 전달하도록 해결했습니다.

Google OAuth 콜백 오류 (400): 구글 로그인 후 redirect_uri_mismatch 오류가 발생했습니다. 이는 EC2 서버의 공인 IP 주소가 구글에 등록되지 않았기 때문입니다. ljmproject.store 도메인을 구입하고, DNS를 설정하여 이 문제를 해결했습니다.

환경 변수 로딩 오류: 도메인을 설정했음에도 불구하고 localhost로 리디렉션되는 문제가 계속되었습니다. 이는 백엔드 컨테이너가 .env 파일을 제대로 읽지 못했기 때문입니다. 최종적으로 docker-compose.yml과 .env 파일의 경로를 다시 확인하고, Google Cloud Console의 리디렉션 URI와 .env 파일의 GOOGLE_CALLBACK_URL 값을 정확히 일치시켜 해결했습니다.

주요 작업 요약
Docker Compose 설정 수정: 데이터베이스와 백엔드 컨테이너의 환경 변수 설정 및 실행 명령어를 여러 차례 수정했습니다.

Nginx 라우팅 규칙 수정: default.conf 파일을 수정하여 프록시 라우팅을 올바르게 변경했습니다.

도메인 구입 및 DNS 설정: ljmproject.store 도메인을 구입하고, 가비아에서 EC2 서버의 공인 IP를 가리키도록 DNS 설정을 완료했습니다.

Google OAuth 설정: Google Cloud Console의 리디렉션 URI를 새로 구입한 도메인으로 변경했습니다.

결론적으로, 로컬 환경에서는 보이지 않던 환경 변수 로딩, 컨테이너 생명 주기, 라우팅, 그리고 외부 서비스(Google) 연동 등 프로덕션 배포 환경에서만 발생하는 다양한 문제를 모두 해결했습니다.

## 자동배포
### 구조
1. 깃허브 main 브랜치에 푸시
2. deploy.yml 파일에 정의된 워크플로우가 자동으로 실행
3. 워크플로우는 프론트엔드와 백엔드 도커 이미지를 빌드하고, ECR에 푸시
4. scp-action을 사용해 docker-compose.yml과 nginx 디렉토리를 EC2로 복사
5. sh-action을 사용해 EC2에 원격으로 접속하여 docker-compose 명령어를 실행
6. docker-compose는 docker-compose.yml 파일을 기반으로 Nginx, 프론트엔드, 백엔드, 데이터베이스 컨테이너를 실행

## HTTPS
- certbot 설치: EC2 서버에 자동화 툴 설치
- 인증서 발급: 이 툴을 사용해 도메인에 대한 SSL 인증서(fullchain.pem, privkey.pem)를 발급
- 인증서 적용: 발급받은 인증서 파일을 deploy.yml의 scp-action과 docker-compose.yml의 volumes를 통해 Nginx 컨테이너로 전달

# 고쳐야할 기능
- jwt 만료시 재발급 유도
- ~~아티클 페이지네이션~~
- 로그인 실패시 api 과다 호출

# 추가 할 생각이 있는 기능
- refreshToken
- 사진첨부 (Firebase)
- jenkins
    - 자동 배포
- 작성된 글 ai 활용
    - 노래, 시 등으로 재가공?
- 게시글 화면 맨 위로 끌어올리기
- 게시글 카드 컬러를 글쓴이가 선택 및 필터링? 카테고리? 해서 색에 따른 의미 부여 할 수 있게 
- 카드형태가 아니라 오브젝트로(책장, usb ...) 분류하고 컨셉에 맞춰 하는게 더 좋은거 같긴 하다
- 새로 생각중인 커뮤니티를 새 프로젝트로 시작할지, 이 프로젝트를 변형시킬지...

# 수정하고 싶은 것들
- 프로젝트를 진행하며 api를 처리하며 든 생각
    - 각 component에서 mutaion을 작성해서 사용하다가 왜 과거의 내가 사용하는 방식에서 후퇴한거지? 라는 생각이 들었다
    - 전에는 vuex에서 mutaion등을 정리해서 사용했었는데...
    - 해당 방식으로 코드 리팩토링 해야겠다.
- 글을 처음에는 post로 했는데, 변수명에 불편함을 느껴 중간부터는 aritlce로 쓰기 시작하며 혼용되어 제3자가 읽기에는 더욱 복잡해졌다. 여유가 있다면 통일하자.

# AI쓰면서 든 생각
- 쉬운 방법 놔두고 어려운 방법으로 하는 경우가 많다
    - 방법을 제시해야 하는 경우가 많다
- 무책임한 느낌의 코드를 던져줄때가 많다
    - 곤란한 코드를 제시하는 경우가 있다.
- 할루시네이션 현상이라고 해야하나... 우리가 나눈 대화를 잊어버리고 다르게 이야기 하는 경우가 많다